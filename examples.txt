1) Python — péssimo (score sugerido: 1)

Problemas: eval em input (RCE), divisão por zero, except genérico, sem validação.

def calculate_average(numbers):
    try:
        return sum(numbers) / len(numbers)
    except:
        pass  # engole erro

user = input("enter a list: ")
numbers = eval(user)  # ⚠️ RCE
print(calculate_average(numbers))  # [] quebra (ZeroDivision)

2) JavaScript — XSS direto (score sugerido: 1-2)

Problemas: usa innerHTML com dado não confiável.

function renderComment(comment) {
  document.getElementById("box").innerHTML = comment; // ⚠️ XSS
}
renderComment(location.hash.slice(1));

3) Python — SQL Injection (score sugerido: 2)

Problemas: interpola string na query, sem parâmetros.

def get_user(conn, username):
    q = f"SELECT * FROM users WHERE name = '{username}'"  # ⚠️ SQLi
    return conn.execute(q).fetchone()

4) Python — token inseguro (score sugerido: 3)

Problemas: usa random em vez de secrets, sem entropia adequada.

import random, string
def make_token(n=16):
    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(n))

5) JavaScript — fetch sem tratamento (score sugerido: 4)

Problemas: sem try/catch, sem timeout/abort, sem checar res.ok.

function fetchUser(id) {
  return fetch("/api/users/" + id)
    .then(r => r.json())
    .then(console.log);
}

6) Python — async errado (score sugerido: 4)

Problemas: time.sleep dentro de async def (bloqueia loop), falta timeout.

import time, asyncio

async def do_work():
    time.sleep(1)  # ⚠️ bloqueia o event loop
    return 42

async def main():
    res = await do_work()
    print(res)

7) Python — O(n²) e naming ruim (score sugerido: 5-6)

Problemas: in em lista dentro de loop; dá pra otimizar com set.

def unique(items):
    out = []
    for x in items:
        if x not in out:
            out.append(x)
    return out

8) React (JS) — vazamento/mau uso de efeito (score sugerido: 5)

Problemas: faltou cleanup do setInterval.

import { useEffect, useState } from "react";

export default function Clock() {
  const [now, setNow] = useState(Date.now());
  useEffect(() => {
    const t = setInterval(() => setNow(Date.now()), 1000);
    // ⚠️ faltou: return () => clearInterval(t)
  }, []);
  return <div>{new Date(now).toLocaleTimeString()}</div>;
}

9) Python — ok, mas sem docstring/validações completas (score sugerido: 7)
from typing import Iterable, Optional

def moving_average(xs: Iterable[float], window: int) -> Optional[float]:
    xs = list(xs)
    if not xs or window <= 0:
        return None
    window = min(window, len(xs))
    return sum(xs[-window:]) / window

10) TypeScript — boa integração com fetch (score sugerido: 8)

Boas práticas: tipagem, encodeURIComponent, AbortSignal, checagem de schema simples.

type User = { id: string; name: string };

export async function getUser(id: string, signal?: AbortSignal): Promise<User> {
  const res = await fetch(`/api/users/${encodeURIComponent(id)}`, {
    signal,
    headers: { Accept: "application/json" },
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data: unknown = await res.json();
  if (typeof (data as any).id !== "string" || typeof (data as any).name !== "string") {
    throw new Error("Invalid schema");
  }
  return data as User;
}

11) Python — robusto/seguro (score sugerido: 9)

Boas práticas: validação, parâmetros na query, logging, tipagem.

import logging, sqlite3
from dataclasses import dataclass
from typing import Iterable

log = logging.getLogger(__name__)

@dataclass(frozen=True)
class Stats:
  count: int
  avg: float

def safe_stats(conn: sqlite3.Connection, values: Iterable[float]) -> Stats:
  vals = [float(v) for v in values]
  if not vals:
      raise ValueError("values must not be empty")

  conn.execute("CREATE TABLE IF NOT EXISTS nums(x REAL)")
  conn.executemany("INSERT INTO nums(x) VALUES (?)", [(v,) for v in vals])  # ✅ param
  row = conn.execute("SELECT COUNT(*), AVG(x) FROM nums").fetchone()
  return Stats(count=int(row[0]), avg=float(row[1]))

12) React + TS — excelente UX/acessibilidade (score sugerido: 9-10)

Boas práticas: debounce, abort, limpeza, encodeURIComponent, ARIA.

import { useEffect, useState } from "react";

export function SearchBox() {
  const [q, setQ] = useState("");
  const [results, setResults] = useState<string[]>([]);

  useEffect(() => {
    const ctrl = new AbortController();
    const id = setTimeout(async () => {
      const term = q.trim();
      if (!term) { setResults([]); return; }
      const res = await fetch(`/api/search?q=${encodeURIComponent(term)}`, { signal: ctrl.signal });
      if (!res.ok) return;
      const data = await res.json();
      setResults(Array.isArray(data) ? data.slice(0, 5) : []);
    }, 250);

    return () => { ctrl.abort(); clearTimeout(id); };
  }, [q]);

  return (
    <div>
      <label htmlFor="search" className="sr-only">Search</label>
      <input id="search" value={q} onChange={e => setQ(e.target.value)} aria-label="Search input" />
      <ul aria-live="polite">
        {results.map(r => <li key={r}>{r}</li>)}
      </ul>
    </div>
  );
}